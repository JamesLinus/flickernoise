\documentclass[11pt, a5paper, pagesize]{scrbook}
\title{Flickernoise handbook}
\usepackage{palatino}
\usepackage{color}
\usepackage{url}
\definecolor{mygray}{gray}{0.92}
\setlength{\parindent}{0in}
\setlength{\parskip}{8pt}
\begin{document}

\newcommand{\mybox}[1] {\fcolorbox{black}{mygray}{\parbox{\textwidth}{#1}}\hspace{2pt}}

\newcommand{\nidmx}{4}
\newcommand{\ndmx}{4}
\newcommand{\nosc}{4}

\maketitle

\chapter{Getting started}

\chapter{Interfaces and controls}
\section{Keyboard controls}
\section{Infrared remote control}
\section{MIDI controls}
\mybox{MIDI messages received through OpenSoundControl are merged with messages coming from the MIDI interface.}
\section{Using DMX512}
\section{Using OpenSoundControl}

\chapter{Authoring patches}
\textit{This chapter is inspired by the MilkDrop guides from Geiss, Rovastar and Krash.}
\section{About patches}
A ``patch'' is a collection of parameters that tell Flickernoise how to draw the wave, how to warp the image around, and so on. Flickernoise ships with dozens of patches, each one having a distinct look and feel to it.

Each patch is saved as a file with the ``.fnp'' extension, so you can easily send them to your friends or post them on the web. You can also go to \url{http://www.milkymist.org} to see what other people have come up with, or post your own cool, new patches.

The Flickernoise rendering engine largely draws ideas from MilkDrop, an audio visualization plug-in for the Winamp music player. In fact, many MilkDrop effects (called ``presets'') can be made to work with Flickernoise, sometimes with only minor modifications.

Four things are useful for writing patches: Mathematics knowledge, artistic flare, persistence and luck. If you have any of these you will be able to create a decent preset and the more of each of these you have the better presets will become. 

Maybe a mathematics textbook will be handy. If you are thinking about maths ``Arrrah, let me out!!'' then don't worry you can create decent patches with very little mathematics knowledge. You will need to know basic operations and what the sine (sin) and cosine (cos) equations roughly do. These are used loads in the Flickernoise patches.

But to be fair the more you know the greater your potential of writing a better patch. You can just randomly put things in and possibly get a decent result, but if you actually understand what you're doing with the mathematics, you'll be able to get specific effects with relative ease. A background in programming doesn't go astray either.

\section{Drawing a wave}
One of the basic elements in a patch is the \textit{wave}, which is a graphical representation of the audio signal much like that of an oscilloscope.

To draw a wave, all that one has to do is select one of the eight possible wave modes, numbered from 0 to 7. This is done by setting the value of the wave\_mode parameter.

Open the patch editor, and enter the text:

\begin{verbatim}
wave_mode=6
\end{verbatim}

\mybox{Flickernoise also recognizes nWaveMode instead of wave\_mode in order to make the porting of MilkDrop presets easier.}

Then, start the rendering by clicking the Run button or pressing the F8 key of the keyboard. Put on some music in order to get a signal to trace other than a straight line. Feel free to experiment with the other wave modes.

\section{Decay}
In the previous example, the wave is repeatedly drawn over itself at each frame, without the screen being cleared. This does not look very nice, and after a while nothing happens anymore as the whole wave drawing area becomes all white.

A solution to this problem comes with the ``decay'' feature of the renderer. What it does is it fades at each frame all the colors to black. It is controlled by a variable names ``decay''. If this variable is 1 (default), no decay is applied (100\% brightness). If it is 0 (0\% brightness), the screen is completely filled with black before drawing the next frame. Intermediate values cover the whole range from 0 to 1. For example a value of 0.99 will darken the image by 1\% at each frame:

\begin{verbatim}
wave_mode=6
decay=0.99
\end{verbatim}

\mybox{Flickernoise also groks fDecay from MilkDrop.}

This gives a nice effect, with the previous traces remaining visible for a while and slowly decaying.

Even though the decay variable is theoretically in the range 0 to 1 it realistically is a range of 0.9 to 1 in most cases. But beware, if you make the decay value at 1 (or very close to), it may eventually turn the entire screen completely white. This is generally to be avoided; always run the patch for a reasonable length of time so ensure that the decay is not too high.

\section{Motion}
\subsection{Zoom}
A popular effect is to make the picture zooming. This is achieved using a variable adequately named ``zoom''.

If this value is 1.0 (default), there is no zoom. If the value is 1.01, the image zooms in 1\% every frame. If the value is 1.10, the image zooms in 10\% every frame. If the value is 0.9, the image zooms out 10\% every frame; and so on.

Increase and decrease the value of the zoom variable to see what the effects are like. As you can see, small changes in the zoom equate to quite noticeable effects. The zooms default normal value is 1 and small amounts of zoom are say 0.9 to 1.1 these look reasonable -- not too drastic. If you make the zoom 20 it makes little or no difference as making it say 5 as it is out of a sensible range. So it important to realise what the ``sensible'' ranges for the variables are. Change the zoom yourself to find a nice range and revert to zoom value back to 1.

\subsection{Displacement}
It is also possible to translate the image at every frame. This is done with the dx and dy variables, which affect horizontal and vertical motion respectively.

These variables are in the range -1 to 1, and have the default value 0. They are expressed in the fraction of the screen to move at each frame. For example, setting the variable dy to 0.01 will move the screen by 1\% at each frame. Since there are typically 24 frames per second, these variables are very sensitive and you'll often want to keep their values small and close to 0.

For example, try and experiment with the following patch (the wave\_x variable controls the position of the wave on the screen):
\begin{verbatim}
wave_mode=6
dy=0.01
wave_x=0.9
\end{verbatim}

\subsection{Rotation}

\subsection{Scaling}

\subsection{Warping}

\section{Other objects}
\subsection{Motion vectors}

\subsection{Borders}

\subsection{Video echo}

\subsection{User pictures}

\subsection{Live video}

\section{Interacting: per-frame equations}
\subsection{Introduction}
Patches get far more interesting if you can take the variables (such as the zoom amount) and animate them (make them change over time). For example, if you could take the ``zoom amount'' parameter and make it oscillate (vary) between 0.9 and 1.1 over time, the image would cyclically zoom in and out, in time.

You can do this -- by writing \textit{per-frame} and \textit{per-vertex} equations. Let's start with per-frame equations. These are executed once per frame. So, if you were to type the following equation in:

\begin{verbatim}
per_frame=zoom = zoom + 0.1*sin(time)
\end{verbatim}

\mybox{To ensure compatibility with MilkDrop, Flickernoise also accepts per\_frame\_xx where xx can be any number.}

...then the zoom amount would oscillate between 0.9 and 1.1 over time. (Recall from your geometry classes that sin() returns a value between -1 and 1). The equation says: "take the static value of ``zoom'', then replace it with that value, plus some variation". This particular equation would oscillate (cycle) every 6.28 seconds, since the sin() function's period is approximately 6.28 ($\approx 2 \cdot \pi$) seconds. If you wanted it to make it cycle every 2 seconds, you could use:

\begin{verbatim}
per_frame=zoom = zoom + 0.1*sin(time*3.14)
\end{verbatim}

Now, let's say you wanted to make the colour of the waveform (sound wave) that gets plotted on the screen vary through time. The colour is defined by three values, one for each of the main colour components (red, green, and blue), each in the range 0 to 1 (0 is dark, 1 is full intensity). You could use something like this:

\begin{verbatim}
per_frame=wave_r = wave_r + 0.5*sin(time*1.13)
per_frame=wave_g = wave_g + 0.5*sin(time*1.23)
per_frame=wave_b = wave_b + 0.5*sin(time*1.33)
\end{verbatim}

It's nice to stagger the frequencies (1.13, 1.23, and 1.33) of the sine functions for the red, green, and blue colour components of the wave so that they cycle at different rates, to avoid them always being all the same (which would create a greyscale wave).

\subsection{Reacting to sound}

\subsection{DMX and OSC controls}

\subsection{The variable monitor}

\section{Fine-tuned motion: per-vertex equations}

\subsection{Q variables}

\mybox{To ensure compatibility with MilkDrop, Flickernoise also accepts per\_vertex\_xx and per\_pixel\_xx where xx can be any number.}

\section{Variable index}
Here is the complete list and description of the variables that can be used in patches. Some are read-only, and some only make sense in the context of per-frame or per-vertex equations.

\subsection{zoom}
Range: $\geq 0$

Controls inward/outward motion; 0.9=zoom out 10\% per frame, 1.0=no zoom, 1.1=zoom in 10\%.

\subsection{rot}
Range: $\geq 0$

Controls the amount of rotation; 0=none, 0.1=slightly counter-clockwise, -0.1=slightly clockwise.

\subsection{warp}
Range: $\geq 0$

Controls the magnitude of the warping; 0=none, 1=normal, 2=major warping...

\subsection{fWarpAnimSpeed}
Range: $\geq 0$

Controls the frequency of the warp effect oscillation.

\subsection{fWarpScale}
Range: $\geq 0$

Controls the amplitude of the warp effect oscillation.

\subsection{fWarpScale}
Range: $\geq 0$

\subsection{cx, cy}
Range: $0..1$

Controls where the centre of rotation and stretching is.

\subsection{dx, dy}
Range: $-1..1$

Controls amount of constant displacement; -0.01=move left (or up) 1\% per frame, 0=none, 0.01=move right (or down) 1\%.

\subsection{sx, sy}
Range: $\geq 0$

Controls amount of constant stretching; 0.99=shrink 1\%, 1=normal, 1.01=stretch 1\%  

\subsection{decay}
Range: $0..1$\\
Alias: fDecay

Controls the eventual fade to black; 1=no fade, 0.9=strong fade.

\subsection{bTexWrap}
Range: $0..1$ (integer)

Controls whether pixels that are pushed into a border of the screen (because of the motion) appear at the opposite corner.

\subsection{wave\_mode}
Range: $0..7$ (integer)\\
Alias: nWaveMode

Selects one of the eight wave drawing modes.

\subsection{wave\_additive}
Range: $0..1$ (integer)\\
Alias: bAdditiveWaves

If this parameter is 1, the waves are drawn by adding to the existing colors instead of replacing the pixels.

\subsection{wave\_brighten}
Range: $0..1$ (integer)\\
Alias: bMaximizeWaveColor

If this parameter is 1, the color components of the wave are scaled until the largest one reaches 1.0.

\subsection{wave\_scale}
Range: $\geq 0$\\
Alias: fWaveScale

Controls the amplitude of the drawn wave.

\subsection{wave\_usedots}
Range: $0..1$ (integer)\\
Alias: bWaveDots

If this parameter is 1, the waves are drawn with dots (yielding a ``stippled'' effect).

\subsection{wave\_thick}
Range: $0..1$ (integer)\\
Alias: bWaveThick

If this parameter is 1, the waves are drawn thicker.

\subsection{wave\_r, wave\_b, wave\_g}
Range: $0..1$

Amount of red, green and blue color in the wave.

\subsection{wave\_a}
Range: $0..1$

Opacity (alpha channel) of the wave. 0=transparent, 1=opaque.

\subsection{wave\_x, wave\_y}
Range: $0..1$

Controls where the wave is drawn on the screen.

\subsection{ob\_size}
Range: $0..0.5$

Thickness of the outer border drawn at the edges of the screen every frame.

\subsection{ob\_r, ob\_b, ob\_g}
Range: $0..1$

Amount of red, green and blue color in the outer border.

\subsection{ob\_a}
Range: $0..1$

Opacity (alpha channel) of the outer border. 0=transparent, 1=opaque.

\subsection{ib\_size}
Range: $0..1$

Thickness of the inner border drawn at the edges of the screen every frame.

\subsection{ib\_r, ib\_b, ib\_g}
Range: $0..0.5$

Amount of red, green and blue color in the inner border.

\subsection{ib\_a}
Range: $0..1$

Opacity (alpha channel) of the inner border. 0=transparent, 1=opaque.

\subsection{mv\_r, mv\_b, mv\_g}
Range: $0..1$

Amount of red, green and blue color in the motion vectors.

\subsection{mv\_a}
Range: $0..1$

Opacity (alpha channel) of the motion vectors. 0=transparent, 1=opaque.

\subsection{mv\_x, mv\_y}
Range: $0..48$\\
Aliases: nMotionVectorsX, nMotionVectorsY

Number of motion vectors in each direction. This number can be non-integer in order to fine-tune the distance between the motion vectors.

\subsection{mv\_dx, mv\_dy}
Range: $0..1$

Controls the position of the origin of the motion vector grid.

\subsection{mv\_l}
Range: $0..5$

Size of the dots used for the motion vectors.

\subsection{time}
Range: $\geq 0$

Retrieves the time, in seconds, since Flickernoise started rendering.

This variable is read only, and can be used in the variable monitor.

\subsection{frame}
Range: $\geq 0$ (integer)

Retrieves the number of displayed frames since Flickernoise started rendering. The nominal frame rate is 24 frames per second.

This variable is read only, and can be used in the variable monitor.

\subsection{bass, mid, treb}
Range: $\geq 0$

Retrieves the current amount of bass (respectively, middle and high frequencies). 1 is normal; below ~0.7 is quiet; above ~1.3 is loud bass (respectively, middle and high frequencies).

These variables are read only, and can be used in the variable monitor.

\subsection{bass\_att, mid\_att, treb\_att}
Range: $\geq 0$

Retrieves an ``attenuated'' reading of the bass, mid and treb variables, meaning that it is damped in time and does not change so rapidly.

These variables are read only, and can be used in the variable monitor.

\subsection{idmx1..idmx\nidmx}
Range: $0..1$

Retrieves the current values of the DMX input channels.

These variables are read only, and can be used in the variable monitor.

\subsection{dmx1..dmx\ndmx}
Range: $0..1$

Sets the values of the DMX output channels.

\subsection{osc1..osc\nosc}
Range: N/A

Retrieves the current values of the OSC input channels.

These variables are read only, and can be used in the variable monitor.

\subsection{x, y}
Range: $0..1$

In per-vertex equations, retrieves the coordinates of the current point.

\subsection{rad}
Range: $\geq 0$

In per-vertex equations, retrieves the distance of the current point to the center of the screen.

\section{Operators and functions index}

\section{Tips and tricks}

\chapter{Community}

\end{document}
